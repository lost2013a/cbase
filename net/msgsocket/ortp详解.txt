五:数据的接收和发送

1、 发送过程:

1. rtp_session_send_with_ts 完成。
在该接口中,会先调用 rtp_session_create_packet 接口,根据缓冲区地址及数据长度,构造一个新的消息块,并根据会话信息初始化 rtp 头信息。
完了将缓冲区中的数据拷贝到消息块中。最后以消息块为参数,调用 rtp_session_sendm_with_ts 接口进行数据发送。
rtp_session_sendm_with_ts调用更底层的函数 
__rtp_session_sendm_with_ts,在该函数中完成具体的发送处理。下面具体分析该函数的实现:

如果发送还没有启动,也就是说当前是第一次启动,则snd_ts_offset 变量首先被设置为应用当前开始的值。
如果启动了调度,则snd_time_offset 设置为调度器运行到现在的时间。这应该算是时间戳的初始化。
如果调度被启用了,则对部分时间戳做一些调整,如下:
首先计算包应该发送的时间,就是packet time。计算方法为在发送第一个数据包时的调度器时间加上包的发送间隔,这个间隔根据应用当前给的时间与第一次的发送给的时间的差 值除以payload 的时钟速率计算得到,比如第一次发送的时间为 100,当前为 300,也就是说发送经过了 200 个单位,如果 payload 的 clock rate 为 10,则说明经过了 20 个时间戳单位, 也就是说当前包的时间戳为调度器时间加 20。(packet time 实际上应该是将下一个包的发送时间转换为调度器时间,交给调度器让调度器来调度)如果计算的packet time与调度器当前的运行时间的差值小于2 的 31 此方,并且二者不相等,则设置该等待点在 packet time唤醒。(关于该比较,参见其他说明部分)

在发送数据前,RTP的时间戳设置为应用传进来的当前的时间戳。snd_last_ts时间戳也 设置为应用当前给的时间戳。

之后就调用实际的发送接口 rtp_session_rtp_send 进行发送。该接口具体会调用 send 系统调用将数据包发送到网络的另一端。

发送完成后调用rtp_session_rtcp_process_send 查看是否需要发送 rtcp 包,依据的原则是:

如果由应用程序询问的最后的时间戳减去以接收单位计算的最后一个rtcp 包发送的时间大于 rtcp 报告包应该发送的时间间隔,或者最后发送数据包的时间戳与按照发送时间戳单位计算的最后一个 rtcp 报告包发送的时间的差值大于 rtcp 应该发送的间隔,就构造 rtcp 的发送者报告包发送。

在构造 rtcp 控制包的过程中,ssrc 源同步描述符采用session 上的源同步描述信息,NTP时间戳使用系统当前的时间加上 1900 到 1970 年间的秒数,实际上这个时间就是 1900 年当当前的秒数了(参见时间戳说明部分)。RTP 时间戳使用snd_last_ts,也就是最后发送的流的时间戳。发送的包数和包字节计数使用session 上RTP 流上统计的计数。另外,如果数据包有被收到,则包含一个报告块,目前的设计也仅只包含一个报告块。数据包构造完成后直 接发送。

如果会话当前的模式为 send-only,则调用 rtp_session_rtcp_recv接收处理 rtcp 包。如果会话支持接收模式,则rtcp 包的接收会在 rtp 接收过程中处理。


数据包的接收是通过调用rtp_session_recv_with_ts 接口完成的。
该接口实际上是调用rtp_session_recvm_with_ts 从底层接收数据,将返回的消息块中的有效数据(不包含rtp 头) 拷贝到用户的buffer 中。
下面具体看 rtp_session_recvm_with_ts 的实现:

如果接收还没有启动,rcv_query_ts_offset设置为应用给定的初始时间,也就是应用询问的时间,记录了一个开始时间偏移。如果发送没有启动或者为 recv-only 模式,则 session 的 last_rcv_time 设置为系统当前的时间。如果设置了调度器,那么rcv_time_offset 设置为调度器启动后运行到当前所用的时间,这个作为接收的时间偏移。如果接收已经启动了,为了避免针对同一个时间戳连续多次接收,这里判断如果当前应用参数给的时间等于rcv_last_app_ts 也即应用程序最近一次询问的时间戳,那么read_socket 变量设置为 FALSE, 避免连续接收。

接下来进入正常的处理流程,首先将rcv_last_app_ts 设置为当前应用时间,也就是更新当前最后一次接收的时间。如果read_socket 设置了,调用 rtp_session_rtp_recv和 rtp_session_rtcp_recv 接口实际的从底层 socket接收数据。

在 rtp_session_rtp_recv 中接收到数据后会调用 rtp_session_rtp_parse 对数据包进行解析。在rtp_session_rtp_parse 中如果发现数据包是 telephone event 包,则会创建一个事件,将其发送到事件队列上,具体处理参见事件部分的说明。Jitter中相关变量的更新也是在该接口中 进行处理的,通过调用jitter_control_new_packet接口完成。最后将数据包放到接收队列上等

待进一步的处理。 从rtp_session_rtp_recv出来后,会检查会话的telephone event队列,如果不为空,则说

明收到了拨号包,一方面需要调用注册的回调函数,另一方面则需要将其发送给事件队列。之后接收就返回了。如果该队列上没有包,则继续处理:

如果设置了接收同步标识,rcv_ts_offset被设置为当前收到的 RTP 数据包中的时间戳。这作为流的第一个时间戳。rcv_last_ret_ts变量则设置为当前应用给出的时间。这里仅仅是给一个初始的值。之后清掉同步标识。因此之前的偏移 rcv_ts_offset 记录了第一个 rtp 数据包的时间戳。后续到达的数据包将不再经过这里的处理逻辑。

调用接口 jitter_control_get_compensated_timestamp 计算流的时间戳。具体参见 jitter 模块说明。 如果 rtp上的jitter 控制是使能的,那么就会利用 jitter buffer 机制对数据包进行流控, 否则,就直接从队列上取一个新的数据包。在 jitter 使能的情况下,如果 session 的 permissive 算法被启用了,那么就调用 rtp_getq_permissive接口获取数据。在该接口中,判断如果计算出的流的时间戳与 rtp 数据包中记录的时间戳的差值小于 2的31 次方,就从队列中弹出一个包返回,否则返回空。如果没有启用permissive 算法则调用 rtp_getq 接口按照正常方式接收数据包。在该接口中,我们返回时间戳等于或者早于计算的时间戳的数据包,如果这样的数据包不止一个,那么扔掉更老的包,也就是从队列上最先取出来的包,最后返回的就是最近一次取出的数据包。如果有两个数据包有相同的时间戳,那么只返回一个。另外,在该接口中如果有数据包也就是更老的包被丢弃了,那么会把丢弃的包数目记载到reject 参数中返回。

如果上一步确有数据包返回,那么会对数据包中的时间戳进行更新,这部分参见对jitter_control_update_corrective_slide接口的说明。随后将 rcv_last_ts 时间戳更新为包原始到达时的时间戳值,即未更新前的值。接着调用rtp_session_rtcp_process_recv 接口进行 rtcp 的接收处理。(之前是发送处理)触发条件和触发后时间量的修改同发送部分。如果最后一次rtcp 的 sr 报告中的发送计数小于统计量中的发送包数的统计,则调用 make_sr 构造 sr 报告包,同时将之前的统计计数更新为统计量中保存的值。如果该值不小于,则说明不需要发送rtcp 的 sr 报告包,但是如果同时接收的包数大于零,就是说有数据包被接收到,则调用 make_rr 构造 rtcp 的 rr 包。如果包构造成功,则调用 rtp_session_rtcp_send发送包。

之后如果没有启动调度,则直接将包返回给上层,不需要再进行特殊处理,否则进行调度的处理。类似与发送部分,同样是根据应用给定的时间和应用第一次调用接收时的时间差值作为参数,调用rtp_session_ts_to_time 接口计算出包的调度时间间隔。这个间隔加上应用询问第一个包时调度器运行的时间作为包的下次调度时间。如果这个时间在调度器当前的时间之后,则就将这个时间作为唤醒点,等待调度器调度。

接收和发送过程中各个时间戳值的关系如下图所示:、